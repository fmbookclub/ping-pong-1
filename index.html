<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ping Pong</title>
    <style>
        :root {
            --bg: #0f1220;
            --table: #141832;
            --accent: #32d295;
            --white: #eaeef6;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: radial-gradient(1000px 600px at 50% 30%, #1a1f3e 0%, var(--bg) 60%, #070914 100%);
            color: var(--white);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        }

        .wrap {
            height: 100%;
            display: grid;
            place-items: center;
            gap: 1rem;
            padding: 1.5rem;
        }

        .hud {
            display: flex;
            gap: 1rem;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            user-select: none;
        }

        .btn {
            background: #1e244a;
            color: var(--white);
            border: 1px solid #2a3265;
            padding: 0.5rem 0.9rem;
            border-radius: 8px;
            cursor: pointer;
            transition: transform .05s ease, background .2s ease;
        }

        .btn:hover {
            background: #242c59;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .score {
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        canvas {
            width: min(90vw, 900px);
            height: min(60vh, 550px);
            max-width: 900px;
            max-height: 550px;
            border-radius: 12px;
            background: linear-gradient(180deg, var(--table) 0%, #0f1430 100%);
            box-shadow:
                0 50px 100px -20px rgba(10, 12, 24, 0.6),
                0 30px 60px -30px rgba(10, 12, 24, 0.7),
                inset 0 0 0 2px #2a3265;
        }

        .help {
            opacity: 0.8;
            font-size: 0.95rem;
            text-align: center;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div class="hud">
            <button class="btn" id="startBtn">Start / Reset</button>
            <button class="btn" id="pauseBtn">Pause</button>
            <span class="score" id="score">0 — 0</span>
            <span id="modeLabel">Mode: 1P (Right paddle AI)</span>
        </div>

        <canvas id="game" width="900" height="550" aria-label="Ping Pong"></canvas>

        <div class="help">
            <p><strong>Left paddle:</strong> W / S keys &nbsp;|&nbsp; <strong>Right paddle:</strong> Up / Down arrows
                (in 2P mode)</p>
            <p><strong>Toggle mode:</strong> M &nbsp;|&nbsp; <strong>Pause:</strong> P &nbsp;|&nbsp;
                <strong>Restart:</strong> R</p>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // UI elements
        const scoreEl = document.getElementById('score');
        const modeLabelEl = document.getElementById('modeLabel');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');

        // Game constants
        const W = canvas.width;
        const H = canvas.height;
        const PADDLE_W = 14;
        const PADDLE_H = 90;
        const PADDLE_MARGIN = 24;
        const BALL_SIZE = 12;
        const NET_W = 4;
        const MAX_BALL_SPEED = 11;
        const PADDLE_SPEED = 7;
        const AI_REACT = 0.18;     // lower = slower reaction
        const AI_MAX_SPEED = 6.5;

        // Game state
        let leftPaddle = { x: PADDLE_MARGIN, y: H / 2 - PADDLE_H / 2, vy: 0 };
        let rightPaddle = { x: W - PADDLE_MARGIN - PADDLE_W, y: H / 2 - PADDLE_H / 2, vy: 0 };
        let ball = { x: W / 2, y: H / 2, vx: 0, vy: 0, speed: 7 };
        let score = { left: 0, right: 0 };
        let running = false;
        let lastTime = 0;
        let onePlayer = true; // right paddle AI by default

        // Utility
        const clamp = (v, min, max) => Math.min(Math.max(v, min), max);

        function resetBall(direction = Math.random() < 0.5 ? -1 : 1) {
            ball.x = W / 2;
            ball.y = H / 2;
            const angle = (Math.random() * 0.6 - 0.3); // -0.3..0.3 radians
            ball.speed = 7;
            ball.vx = Math.cos(angle) * ball.speed * direction;
            ball.vy = Math.sin(angle) * ball.speed;
        }

        function drawCourt() {
            // Background is CSS; draw center line/net and boundaries
            ctx.fillStyle = '#2a3265';
            ctx.fillRect(W / 2 - NET_W / 2, 0, NET_W, H);

            // Dotted center circle
            ctx.strokeStyle = '#2a3265';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 12]);
            ctx.beginPath();
            ctx.arc(W / 2, H / 2, 80, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawPaddle(p) {
            ctx.fillStyle = '#eaeef6';
            ctx.fillRect(p.x, p.y, PADDLE_W, PADDLE_H);

            // Subtle glow
            ctx.shadowColor = '#32d295';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.fillStyle = 'rgba(50,210,149,0.15)';
            ctx.fillRect(p.x - 2, p.y - 2, PADDLE_W + 4, PADDLE_H + 4);
            ctx.shadowBlur = 0;
        }

        function drawBall() {
            ctx.fillStyle = '#32d295';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, BALL_SIZE / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function render() {
            ctx.clearRect(0, 0, W, H);
            drawCourt();
            drawPaddle(leftPaddle);
            drawPaddle(rightPaddle);
            drawBall();
        }

        function update(dt) {
            // Move paddles
            leftPaddle.y += leftPaddle.vy * dt;
            rightPaddle.y += rightPaddle.vy * dt;

            // Clamp paddles
            leftPaddle.y = clamp(leftPaddle.y, 0, H - PADDLE_H);
            rightPaddle.y = clamp(rightPaddle.y, 0, H - PADDLE_H);

            // AI control for right paddle
            if (onePlayer) {
                const targetY = ball.y - PADDLE_H / 2;
                const diff = targetY - rightPaddle.y;
                const aiSpeed = clamp(diff * AI_REACT, -AI_MAX_SPEED, AI_MAX_SPEED);
                rightPaddle.y += aiSpeed * dt;
                rightPaddle.y = clamp(rightPaddle.y, 0, H - PADDLE_H);
            }

            // Move ball
            ball.x += ball.vx * dt;
            ball.y += ball.vy * dt;

            // Wall collisions
            if (ball.y <= BALL_SIZE / 2) {
                ball.y = BALL_SIZE / 2;
                ball.vy *= -1;
            }
            if (ball.y >= H - BALL_SIZE / 2) {
                ball.y = H - BALL_SIZE / 2;
                ball.vy *= -1;
            }

            // Paddle collisions
            // Left
            if (ball.x - BALL_SIZE / 2 <= leftPaddle.x + PADDLE_W &&
                ball.y >= leftPaddle.y &&
                ball.y <= leftPaddle.y + PADDLE_H &&
                ball.vx < 0) {

                const rel = (ball.y - (leftPaddle.y + PADDLE_H / 2)) / (PADDLE_H / 2);
                const bounceAngle = rel * (Math.PI / 4); // max 45 degrees
                ball.speed = clamp(ball.speed * 1.05, 7, MAX_BALL_SPEED);
                ball.vx = Math.cos(bounceAngle) * ball.speed;
                ball.vy = Math.sin(bounceAngle) * ball.speed;
                ball.x = leftPaddle.x + PADDLE_W + BALL_SIZE / 2 + 0.01;
            }

            // Right
            if (ball.x + BALL_SIZE / 2 >= rightPaddle.x &&
                ball.y >= rightPaddle.y &&
                ball.y <= rightPaddle.y + PADDLE_H &&
                ball.vx > 0) {

                const rel = (ball.y - (rightPaddle.y + PADDLE_H / 2)) / (PADDLE_H / 2);
                const bounceAngle = rel * (Math.PI / 4);
                ball.speed = clamp(ball.speed * 1.05, 7, MAX_BALL_SPEED);
                ball.vx = -Math.cos(bounceAngle) * ball.speed;
                ball.vy = Math.sin(bounceAngle) * ball.speed;
                ball.x = rightPaddle.x - BALL_SIZE / 2 - 0.01;
            }

            // Scoring
            if (ball.x < -BALL_SIZE) {
                score.right += 1;
                updateScore();
                resetBall(1);
            } else if (ball.x > W + BALL_SIZE) {
                score.left += 1;
                updateScore();
                resetBall(-1);
            }
        }

        function updateScore() {
            scoreEl.textContent = `${score.left} — ${score.right}`;
        }

        function loop(timestamp) {
            if (!running) return;
            if (!lastTime) lastTime = timestamp;
            const dt = Math.min((timestamp - lastTime) / (1000 / 60), 3); // normalize to ~60fps units, clamp
            lastTime = timestamp;

            update(dt);
            render();
            requestAnimationFrame(loop);
        }

        // Controls
        const keys = new Set();

        function handleKeys() {
            // Left paddle: W/S
            leftPaddle.vy = 0;
            if (keys.has('KeyW')) leftPaddle.vy = -PADDLE_SPEED;
            if (keys.has('KeyS')) leftPaddle.vy = PADDLE_SPEED;

            // Right paddle: Up/Down in 2P mode
            rightPaddle.vy = 0;
            if (!onePlayer) {
                if (keys.has('ArrowUp')) rightPaddle.vy = -PADDLE_SPEED;
                if (keys.has('ArrowDown')) rightPaddle.vy = PADDLE_SPEED;
            }
        }

        document.addEventListener('keydown', (e) => {
            keys.add(e.code);
            handleKeys();

            if (e.code === 'KeyP') togglePause();
            if (e.code === 'KeyR') startGame(true);
            if (e.code === 'KeyM') toggleMode();
        });

        document.addEventListener('keyup', (e) => {
            keys.delete(e.code);
            handleKeys();
        });

        // Buttons
        startBtn.addEventListener('click', () => startGame(true));
        pauseBtn.addEventListener('click', togglePause);

        function startGame(reset = false) {
            if (reset) {
                score.left = 0;
                score.right = 0;
                updateScore();
                leftPaddle.y = H / 2 - PADDLE_H / 2;
                rightPaddle.y = H / 2 - PADDLE_H / 2;
                resetBall();
            }
            running = true;
            lastTime = 0;
            requestAnimationFrame(loop);
        }

        function togglePause() {
            running = !running;
            if (running) {
                lastTime = 0;
                requestAnimationFrame(loop);
            }
        }

        function toggleMode() {
            onePlayer = !onePlayer;
            modeLabelEl.textContent = `Mode: ${onePlayer ? '1P (Right paddle AI)' : '2P (Both human)'}`;
        }

        // Start with a ready ball but paused; press Start to play
        resetBall();
        render();
        updateScore();
        modeLabelEl.textContent = `Mode: ${onePlayer ? '1P (Right paddle AI)' : '2P (Both human)'}`;
    </script>
</body>

</html>
